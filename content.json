[{"title":"UILabel-AFNetworking-显示下载百分比","date":"2017-02-04T09:55:22.000Z","path":"2017/02/04/UILabel-AFNetworking-显示下载百分比/","text":"用处：利用AFNetworking做下载操作的时候，利用UILabel动态显示下载百分比，显示格式如下：百分比%。 如何实现：我们调用AFNetworking做下载的时候，一般会创建一个NSURLSessionDownloadTask对象，调用AFURLSessionManager的方法： 1234- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)requestprogress:(NSProgress * __autoreleasing *)progressdestination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destinationcompletionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler; NSURLSessionDownloadTask继承于NSURLSessionTask，我们向捕获下载进度，实际就是监听NSURLSessionTask上的countOfBytesReceived和state属性，实时改变UILabel的显示文案即可。 源码：UILabel+AFNetworking.h 123456789#import &lt;UIKit/UIKit.h&gt;@interface UILabel (AFNetworking)- (void)setProgressWithDownloadProgressOfTask:(NSURLSessionDownloadTask *)task;- (void)removeProgressOfTaskInfo:(NSURLSessionDownloadTask *)task;@end UILabel+AFNetworking.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#import &quot;UILabel+AFNetworking.h&quot;static void * AFTaskCountOfBytesReceivedContext = &amp;AFTaskCountOfBytesReceivedContext;@implementation UILabel (AFNetworking)- (void)setProgressWithDownloadProgressOfTask:(NSURLSessionDownloadTask *)task&#123;[task addObserver:self forKeyPath:@&quot;state&quot; options:(NSKeyValueObservingOptions)0 context:AFTaskCountOfBytesReceivedContext];[task addObserver:self forKeyPath:@&quot;countOfBytesReceived&quot; options:(NSKeyValueObservingOptions)0 context:AFTaskCountOfBytesReceivedContext];&#125;- (void)removeProgressOfTaskInfo:(NSURLSessionDownloadTask *)task &#123;if (task) &#123;@try &#123;[task removeObserver:self forKeyPath:@&quot;state&quot;];[task removeObserver:self forKeyPath:@&quot;countOfBytesReceived&quot;];&#125; @catch (NSException *exception) &#123;&#125;&#125;&#125;#pragma mark - NSKeyValueObserving- (void)observeValueForKeyPath:(NSString *)keyPathofObject:(id)objectchange:(__unused NSDictionary *)changecontext:(void *)context&#123;if (context == AFTaskCountOfBytesReceivedContext) &#123;if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesReceived))]) &#123;if ([object countOfBytesExpectedToReceive] &gt; 0) &#123;dispatch_async(dispatch_get_main_queue(), ^&#123;CGFloat progressValue = (CGFloat)[object countOfBytesReceived] / (CGFloat)[object countOfBytesExpectedToReceive] * 100.0;NSString *progress = [NSString stringWithFormat:@&quot;%lld%%&quot;, (int64_t)progressValue];self.text = progress;&#125;);&#125;&#125;if ([keyPath isEqualToString:NSStringFromSelector(@selector(state))]) &#123;if ([(NSURLSessionTask *)object state] == NSURLSessionTaskStateCompleted) &#123;@try &#123;[object removeObserver:self forKeyPath:NSStringFromSelector(@selector(state))];if (context == AFTaskCountOfBytesReceivedContext) &#123;[object removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))];&#125;&#125;@catch (NSException * __unused exception) &#123;&#125;&#125;&#125;&#125;&#125;@end 用法：1[yourLabel setProgressWithDownloadProgressOfTask:yourDownloadTask]; 监听到下载完成，会自动移除掉obersver，如果想在下载到一半的时候移除监听，调用： 1[yourLabel removeProgressOfTaskInfo:yourDownloadTask]; 项目需要，所以写了这样的一个Category，其实相应的还可以做上传的动态监测，AFNetworkging自己也有一个UIKit+AFNetworking的group下实现了很多UIKit下控件关于AFNetworking的Category，大家可以去看下啦~~","tags":[{"name":"kvo","slug":"kvo","permalink":"http://yoursite.com/tags/kvo/"},{"name":"AFNetworking","slug":"AFNetworking","permalink":"http://yoursite.com/tags/AFNetworking/"}]},{"title":"Objective-C封装std::priority_queue<>实现优先队列","date":"2016-12-05T09:40:25.000Z","path":"2016/12/05/Objective-C封装std-priority-queue-实现优先队列/","text":"最近项目中需要用到优先队列，google了半天，发现Cocoa Foundation中竟然木有现成的好用的轮子可以拿来用。找了半天，也只有Core Foundation的CFBinaryHeap算是满足需求，但是CFBinaryHeap需要自己管理释放对象，而且不能实时更新heap中的值，再一看文档中提供的方法，辣么多回调列在那里，做为一个前C++开发者，我想我还不如用我熟悉一点的std::priority_queue来实现我的需求吧。 回忆下什么是优先队列讲到队列一般人都知道，先进先出嘛，就和排队买东西一样，先来的人排在前面，买完就从队列里出去了。那什么是优先队列呢，假设我们生活在一个特别尊老爱幼的社会，每次排队买东西的时候，都要按照年龄作为优先级比较的参照，年纪大的在最前面，年纪小的在其次，青壮年排在后面，老爷爷老奶奶买完了，才轮到小孩儿，小孩儿们正买着辣条呢呢，忽然又来了个老奶奶，大家于是很懂礼貌的让老奶奶排到了第一个，等老奶奶抢完了超市里的土鸡蛋离开队伍后，才轮到刚刚正准备买辣条的小孩子继续买。 用OC封装std::priority_queueSTL中的priority_queue是C++基于heap实现的优先队列模板类，其鲁棒性和性能已经经过了无数开发者的考验。所以我们放心大胆的用吧。 首先定义一下std::priority_queue&lt;&gt;的包装类: 123456789101112131415161718----PriorityQueue.h----@interface QueueIntNodeObject : NSObject@property (nonatomic, assign) NSUInteger compareValue;@end@interface PriorityQueue : NSObject@property (nonatomic, readonly) QueueIntNodeObject *topObject;@property (nonatomic, readonly) NSUInteger count;- (void)pushObject:(QueueNodeObject *)myObject;- (void)popObject;- (void)popAllObjects; QueueIntNodeObject是优先队列中所要管理的对象的基类，目前先实现以NSUInteger做为比较优先级的类型，有需要的可以扩展其他的基类出来。PriorityQueue是用来包装std::priority_queue的wrapper。定义几个常用的属性和方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465----PriorityQueue.mm----#import &quot;PriorityQueue.h&quot;#include &lt;queue&gt;class QueueCompare &#123;public: bool operator()(QueueIntNodeObject *l, QueueIntNodeObject *r) const &#123; if (l.compareValue &lt; r.compareValue) &#123; return true; &#125;else &#123; return false; &#125; &#125;&#125;;typedef std::priority_queue&lt;QueueIntNodeObject *, std::vector&lt;QueueIntNodeObject *&gt;, QueueCompare&gt; Queue;#pragma mark - QueueIntNodeObject@implementation QueueIntNodeObject@end#pragma mark - PriorityQueue@interface PriorityQueue ()@property (nonatomic) Queue *priority_queue;@end@implementation PriorityQueue- (instancetype)init &#123; self = [super init]; if (self) &#123; _priority_queue = new Queue(); &#125; return self;&#125;- (void)dealloc &#123; delete _priority_queue; _priority_queue = NULL;&#125;- (QueueIntNodeObject *)topObject &#123; return !self.priority_queue-&gt;empty() ? self.priority_queue-&gt;top() : nil;&#125;- (NSUInteger)count &#123; return (NSUInteger)self.priority_queue-&gt;size();&#125;- (void)popObject &#123; if (!self.priority_queue-&gt;empty()) &#123; self.priority_queue-&gt;pop(); &#125;&#125;- (void)pushObject:(QueueIntNodeObject *)myObject &#123; self.priority_queue-&gt;push(myObject);&#125;- (void)popAllObjects &#123; if (!self.priority_queue-&gt;empty()) &#123; delete _priority_queue; _priority_queue = new Queue(); &#125;&#125;@end QueueCompare定义一个C++类，用来重载()运算符，实现两个QueueIntNodeObject对象的比较。 1typedef std::priority_queue&lt;QueueIntNodeObject *, std::vector&lt;QueueIntNodeObject *&gt;, QueueCompare&gt; Queue; 给priority_queue另外定义个名字，这个实在太长了。下面就是实现PriorityQueue的几个方法，每个方法对应的即是操作std::priority_queue的方法。当然别忘了再不使用std::priority_queue的时候delete掉，否则会有内存泄漏。 我们再来看段实例代码，以前面举的排队的例子，先定义一个排队的人的对象，对象有两个属性，名称和年纪： 12345678910111213141516@interface Person : QueueIntNodeObject@property (nonatomic, copy) NSString *name;- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age;@end@implementation SeatInfo- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age &#123; if (self = [super init]) &#123; self.name = name; self.compareValue = age; &#125; return self;&#125;@end 然后再创建几个Person对象，放到队列管理去。 123456789101112131415161718192021222324252627Person *s1 = [[Person alloc] initWithName:@&quot;贾母&quot; age:70];NSLog(@&quot;Retain count is %ld&quot;, CFGetRetainCount((__bridge CFTypeRef)s1));Person *s2 = [[Person alloc] initWithName:@&quot;宝玉&quot; age:16];Person *s3 = [[Person alloc] initWithName:@&quot;黛玉&quot; age:15];Person *s4 = [[Person alloc] initWithName:@&quot;宝钗&quot; age:17];Person *s5 = [[Person alloc] initWithName:@&quot;妙玉&quot; age:18];Person *s6 = [[Person alloc] initWithName:@&quot;贾政&quot; age:40];Person *s7 = [[Person alloc] initWithName:@&quot;凤姐儿&quot; age:20];Person *s8 = [[Person alloc] initWithName:@&quot;平儿&quot; age:19];PriorityQueue *queue = [[PriorityQueue alloc] init];[queue pushObject:s1];[queue pushObject:s2];[queue pushObject:s3];[queue pushObject:s4];[queue pushObject:s5];[queue pushObject:s6];[queue pushObject:s7];[queue pushObject:s8];NSLog(@&quot;Retain count is %ld&quot;, CFGetRetainCount((__bridge CFTypeRef)s1));while (queue.count) &#123; Person *person = (Person *)[queue topObject]; NSLog(@&quot;%@&quot;, person.name); [queue popObject];&#125;NSLog(@&quot;Retain count is %ld&quot;, CFGetRetainCount((__bridge CFTypeRef)s1)); 这段代码执行后，会按年龄从大到小输出person对象，达到了我们想要的按照年纪作为优先级参照输出的效果。并且，我在其中加入了输出person对象引用计数的log,运行后发现，priority_queue在ARC下也很好的管理了计数，person对象在被push到queue中后，queue对其持强引用，引用计数加1，从queue中pop出来后，引用计数减1。所以我们依旧不用担心如何在ARC中管理内存。 如果想实现更复杂的优先级的控制，只需要实现一个类似于QueueIntNodeObject的类和一个用于比较优先级的类即可。是不是很简单啦啦啦~~~ 文中代码都提交到 github 啦：https://github.com/LicoC/PriorityQueue ， 欢迎star 😝","tags":[{"name":"priority_queue","slug":"priority-queue","permalink":"http://yoursite.com/tags/priority-queue/"}]}]